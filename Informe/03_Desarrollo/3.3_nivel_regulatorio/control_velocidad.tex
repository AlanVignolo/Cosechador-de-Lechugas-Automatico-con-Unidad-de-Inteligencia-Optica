El control de velocidad se implementa mediante Timer1 del ATmega2560 configurado en modo CTC (Clear Timer on Compare Match) con frecuencia variable.

\subsubsection{Generación de Pulsos y conversión de velocidad a OCR1A}

El Timer1 genera interrupciones a frecuencia configurable que alternan el estado del pin STEP entre alto y bajo, creando los pulsos necesarios para el driver TB6600. Cada transición alto-bajo constituye un paso del motor. El sistema cuenta los pasos ejecutados y controla la frecuencia de interrupción mediante el registro de comparación OCR1A del timer:

\begin{equation}
f_{step} = \frac{f_{CPU}}{2 \cdot prescaler \cdot (OCR1A + 1)}
\end{equation}

donde $f_{CPU} = 16$ MHz, prescaler = 8, y OCR1A se calcula dinámicamente.

Para una velocidad deseada $v$ en pasos/s, el valor de OCR1A es:

\begin{equation}
OCR1A = \frac{f_{CPU}}{2 \cdot prescaler \cdot v} - 1 = \frac{16000000}{2 \cdot 8 \cdot v} - 1 = \frac{1000000}{v} - 1
\end{equation}

Ejemplo: Para $v = 5000$ pasos/s, $OCR1A = 199$. Para $v = 10000$ pasos/s, $OCR1A = 99$.

El firmware precalcula y limita OCR1A para evitar overflow y garantizar estabilidad.